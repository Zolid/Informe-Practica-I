% Template:     Informe/Reporte LaTeX
% Documento:    Archivo de ejemplo
% Versión:      4.3.6 (30/07/2017)
% Codificación: UTF-8
%
% Autor: Pablo Pizarro R.
%        Facultad de Ciencias Físicas y Matemáticas
%        Universidad de Chile
%        pablo.pizarro@ing.uchile.cl, ppizarror.com
%
% Manual template: [http://latex.ppizarror.com/Template-Informe/]
% Licencia MIT:    [https://opensource.org/licenses/MIT/]

% NUEVA SECCIÓN
% Las secciones se inician con \section, si se quiere una sección sin "número" se pueden usar las funciones \sectionanum (sección sin número) o la función \sectionanumnoi para crear el mismo título sin numerar y sin aparecer en el índice
\section{Introducción}
	
	% SUB-SECCIÓN
	% Las sub-secciones se inician con \subsection, si se quiere una sub-sección sin "número" se pueden usar las funciones \subsectionanum (nuevo subtítulo sin numeración) o la función \subsectionanumnoi para crear el mismo subtítulo sin numerar y sin aparecer en el índice
	\subsection{Lugar de Trabajo}
		
		\newpar{La prática profesional se realizó en el Web Intelligence Centre \cite{ref1}, en adelante WIC, es un centro de investigación dependiente de la Facultad de Ciencias Físicas y Matemáticas de la Universidad de Chile, dirigido por el académico Juan Velásquez del Departamento de Ingeniería Industrial de la Universidad de Chile. Su misión es desarrollar investigación en el campo de Tecnologías de Información creando soluciones para abordar problemas complejos de ingeniería utilizando herramientas basadas en la Web de las Cosas. Se encuentra ubicado en Beaucheff \#993, Santiago, Chile. El trabajo se realizó de forma presencial en las instalaciones del centro, entre el 3 al 31 de Enero de 2017. En figura \ref{organigrama} es posible apreciar el organigrama del centro.}
		

	\subsection{Grupo de trabajo}
	
		\newpar{En el WIC trabajan investigadores de tiempo completo, desarrolladores con experiencia, profesionales del área de la salud debido a que muchos de sus proyectos son en conjunto con la Facultad de Medicina, alumnos de pregrado que pueden ser memorista sobre algún tema de investigación o trabajadores part-time y estudiantes de magister del Departamento de Ingeniería Industrial. En particular la oficina donde se realizó el trabajo era usada regularmente por 6 personas, de los cuales había un investigador, dos memoristas, un ingeniero de proyectos y otro practicante que también trabajó en el \textit{Proyecto AKORI}. El \textit{Proyecto AKORI} \cite{ref2} es dirigido por el Ingeniero de Proyecto, Felipe Vera, quien fue el tutor del practicante 
(pero no se encontraba en la misma oficina).}

\subsection{Equipos y Software}	
	
		\subsubsection{Software}
			\newpar{El software utilizado para desarrollar el trabajo fue \textit{Python} \cite{ref3} como lenguaje de programación (a través del IDLE Pycharm proporcionado por JetBrains \cite{ref4}), el framework para aplicaciones Web Python, \textit{Django} \cite{ref5}, \textit{JavaScript} y \textit{AJAX} para la creación de páginas web dinámicas, \textit{Git} para el manejo de control de versiones, el navegador sin interfaz gráfico (conocido como headless browser), PhantomJS, el entorno de pruebas software para aplicaciones web, Selenium \cite{ref6}, dos bibliotecas de Python, una para edición de imágenes, Python Imaging Library, y otra para la generación de un mapa de colores, Matplotlib, y el sistema operativo Ubuntu 16.04 LTS. Además cabe descatar del aplicación del \textit{Proyecto AKORI} \cite{ref2} en la cual se trabajo. A continuación se presenta una breve descripción de los elementos más relevantes para el desarrollo y compresión del trabajo realizado:}
			\begin{enumerate}
				\item \textbf{Python}: Es un lenguaje de programación interpretado cuya filosofía 
				hace hincapié en una sintaxis que favorezca un código legible. Se trata de un 
				lenguaje de programación multiparadigma, ya que soporta orientación a objetos, 
				progrmación imperativa y, en menor medida, programación funcional. En el contexto 
				del trabajo Python sirvió como lenguaje de programación por el lado del servidor 
				para la aplicación web que actualmente funciona como prototipo al \textit{Proyecto AKORI}. 
				\item \textbf{Django}: Es un framework de desarrollo web de código abierto (\textit{open source}), escrito en \textit{Python} que respeta el patrón de diseño conocido como 
				Modelo-Vista-Controlador (MCV) \cite{ref7}, que en pocas palabras separa los componentes más 
				importantes de una aplicación es tres grandes grupos, el modelo donde descansan los
				datos de la aplicación (Base de Datos), la vista que se encarga de todo el aspecto 
				visual de una aplicación, y los controladores que ejecutan toda la lógica de
				funcionamiento. \\ 
				En el caso de \textit{Django} tiene la perculiaridad que las vistas reciben el 
				nombre templates (encargados del \textit{fontend} de la aplicación) y los 
				controladores se llaman vistas (Views en inglés y encargadas del \textit{backend}). 	
				Para el trabajo realizado fue necesario tomar la aplicación desarrollada, añadir
				cambios en los templates y agregar algunas funciones a las vistas para controlar 
				la lógica del mapa de objetos que en las próximas secciones serán explicadas en 
				detalle.
				\item \textbf{JavaScript} y \textbf{AJAX}: Es un lenguaje de programación que 
				es utilizado para la creación de páginas web de dinámicas por el lado del cliente
				en una aplicación web. \textit{AJAX} es una extensión a la funcionalidad de 
				\textit{Javascript} que hace llamadas asíncronas al servidor web obteniendo 
				información sin recargar las página por completo. Dentro del trabajo de prática
				fueron utilizados para obtener el input de datos para el despliegue del mapa de 
				objetos sin recargar toda la aplicación en la consulta. 
				\item \textbf{PhantomJS}: Es un navegador sin interfaz gráfica que sirve para 
				realizar pruebas a una aplicación que se encuentra en fase de desarrollo. Fue 
				utilizado para realizar web scraping \cite{ref8}, término que describe la recolección de 
				información a través de la Web usando programas automatizados.
				\item \textbf{Selenium}: Es un entorno de pruebas de software para aplicaciones 
				basadas en la web, con bibliotecas existentes para muchos lenguajes de programación
				como \textit{Python} y \textit{JAVA}. Se usó para realizar el web scrapping 
				junto a \textit{PhantomJS} sobre los distintas sitios web que fueron testeados.
			\end{enumerate}
	\subsubsection{\textit{Proyecto AKORI}}
	
		\newpar{Para contextualizar de mayor forma el trabajo de práctica realizado a continuación 
		se explicará brevemente que es el \textit{Proyeto AKORI} \cite{ref2} y cuál es su meta a seguir. \\ 
		Antes de eso es necesario definir que son los objetos web \cite{ref9}, y que se entiende cuando se habla de ellos dentro del mapa de objetos, estos son definidos como la combinación grupal
		o individual de elementos pertencientes al \textit{DOM} \cite{ref10}. En adelante cuando hablemos de 
		objetos claves o simplemente de objetos nos referimos a los de la definición anterior. \\
		El objetivo del \textit{proyecto AKORI} es desarrollar una plataforma virtual que permita extrapolar el 
		comportamiento de navegación de los usuarios cuando ingresan a sitio web a partir de la 
		extracción de patrones de datos analizados con técnicas de minería de datos, eye tracking, 
		y encefalografía. Para lograr esto, el proyecto se divide en 5 grandes etapas que son las 
		siguientes:
			\begin{enumerate}
				\item Adaptar y refinar un repositorio de datos elaborado con estímulos visuales obtenidos desde sitios web, incorporando los datos de un mayor número de personas y diferenciándolos según variables sociodemográficas.
				\item Adaptar e integrar algoritmos de minería de datos masivos (big data) para determinar patrones que permitan caracterizar y extrapolar la navegación de un usuario en un sitio web mediante análisis de exploración visual utilizando datos provenientes desde eye-tracking, dilatación pupilar y electroencefalografía.
				\item Diseñar, construir y evaluar una plataforma prototipo que integre algoritmos de web Intelligence, un repositorio de datos en base a estímulos visuales y electroencefalografía con patrones de comportamiento web para extrapolar las preferencias y el comportamiento de potenciales usuarios web.
				\item Testear y evaluar funcionalidades del sitio, capacidad del sistema para lograr lo que se desea y minimizar errores de uso; además de medir el nivel de usabilidad (facilidad de aprender y recordar, eficiencia, minimización de errores de uso y satisfacción del usuario).
				\item Prospectar y valorizar el mercado, como también la propiedad intelectual. Definir una estrategia para el empaquetamiento y transferencia de la tecnología.
			\end{enumerate}
			A pesar de que las investigaciones continúan, existe un propotipo de la aplicación web
			con algunos módulos (mapas esquemativos) en desarrollo y otros ya implementados. A continuación se escriben los módulos ya implementados, incluido el que desarrollo el practicante.
				\begin{enumerate}
					\item \textbf{Mapa de Fijación Ocular}: Contruye un mapa de calor con las zonas
					más probables de fijación ocular en un sitio web a partir de una escala de 
					colores. Los clientes pueden visualizar las zonas mas vistas en rojo, las menos 
					vistas en azul y las que tiene ninguna probabilidad de ser vistas adquieren un 
					color en escala de grises.
					\item \textbf{Mapa de Dilatación Pupilar}: Construye un mapa calor siguiendo una
					escala similar al mapa de fijación ocular, con la diferencia que las zonas que 
					adquieren colores más intensos muestra donde es más probable que un usuario haga
					un click dentro de la página analizada.
					\item \textbf{Mapa de Objetos de Claves}: Se construye un mapa que muestra los
					objetos web más relevantes que un usuario visualiza al ingresar a un sitio web, 
					los objetos más importantes son coloreados con más oscuros que los menos vistos. 
				\end{enumerate}
			Además de los módulos explicados anteriormente, se está trabajando en tres mapas más 
			que aún no han sido llevados a producción, estos son, el índice de claridad, el mapa de 
			probabilidad de ticks, y el mapa de percepción; donde los primeros dos son complementos
			a los ya implementados, y el último mostrará donde es más probable que el usuario 
			dirigirá la mirada los primeros tres segundos de ingresar al sitio web. \\ 
			En las figuras \ref{akori}, \ref{reporte}, \ref{cargando}, \ref{mapas} puede apreciarse
			la interfaz de la plataforma mientras se analiza la página de \textit{GOOGLE}. 				 
			}
		
	\subsubsection{Equipo}
	
		\newpar{En cuanto a los equipos computacionales, el centro provee tanto equipos
		estacionarios como portátiles para aquellos que encuentran trabajando e investigando, 
		sin embargo para los prácticantes y memoristas deben llevar sus equipos personales 
		para desarrollar sus labores. En particular la prática realizada solo fue necesario un
		equipo portátil para programar el mapa de objetos.}

	\subsection{Situación Previa}
	
		\newpar{A continuación se describirá la situación previa al trabajo del practicante. Esta
		descripción se centrará en dos versiones del \textit{Proyecto AKORI}, una escrita en 
		\textit{Python} utilizando el framework \textit{Django} que actualmente está producción 
		y la otra escrita en \textit{Java} usando \textit{Servlet} que ya no se encuentra en
		funcionamiento.} 
		\subsubsection{Versión \textit{Java} con \textit{Servlet}} \label{subseccion141}
			\newpar{En esta versión estaban implementados la mayoría de los modulos que fueron 
			explicados en la sección anterior. Además una versión del mapa de objetos claves
			que sin embargo, resaltaba todos elementos del sitio web (ver figura \ref{mapadeobjetosv1}) y no filtraba
			los elementos de mayor a menor interés. En el siguiente extracto del código se puede 
			apreciar el algoritmo del mapa de objetos claves.}
			
			\begin{lstlisting}[style=Java, caption={Código mapa de objetos versión 1.\label{version-java}}]
           	query = driver.findElements(By.tagName(temp.tagName()));
            for (WebElement temp1 : query) {
                     try{
                    Point po = temp1.getLocation();
                    Dimension d = temp1.getSize();
                    if (d.width <= 0 || d.height <= 0 || po.x < 0 || po.y < 0) {
                        continue;
                    }
                    graph.draw(new Rectangle(po.x, po.y, d.width, d.height));
                     }
                     catch (ElementNotVisibleException ex){
                         System.out.println("Objeto no visible O:");
                     }
                     catch (StaleElementReferenceException ex){
                          System.out.println("Parece que el objeto ya no existe");
                     }
                     catch (NoSuchElementException ex ){
                         System.out.println("Parece que el objeto ya no existe II");
                     ex.printStackTrace();
                     }
                    ++i;
                }
            }
        }
\end{lstlisting}
	\newpar{A grandes rangos este código realizaba lo siguiente, almacenaba en la variable 
	\textit{query} todos los objetos web provenientes del \textit{DOM} en una instancia de la clase
	\textit{ArrayList}, para luego a entrar a un ciclo donde se dibujaba un rectángulo 
	(que encerraba al objeto web) de acuerdo a la posición y las dimensiones de cada objeto web sobre una 
	imagen tomada del sitio web que se estaba analizando. Como en está versión no existía una 
	clase especial para el mapa de objetos solo se incluye el extracto del código relacionado al 
	trabajo realizado. \\ \\
	Para el practicante, entender todas clases de la versión \textit{JAVA} no fue una tarea difícil
	debido a que contaba con experiencia previa programando con dichas tecnologías.}
			
			
		\subsubsection{Versión \textit{Django}}
			\newpar{Previo al trabajo del practicante solo existía una implementación de los
			mapas de fijación ocular y dilatación pupilar. Como esta versión estaba hecha 
			utilizando el framework \textit{Django}, seguía los principios de programación 
			de \textit{Python}, además de la clara separación de componentes que \textit{Django}
			administra (patrón MVC), que es muy diferente a la arquitectura que ofrece 
			la programación web \textit{JAVA} y su contenedor de \textit{Servlet}. Sin 
			embargo, la funcionalidad e interfaz gráfica era la misma que la versión previa
			a la migración del lenguaje que manejaba el servidor web.}
	
	\subsection{Descripción general del trabajo realizado} 
	
		\newpar{Como ya se mencionó en secciones anteriores, el objetivo del trabajo desarrollado
		fue el proveer un mapa que resaltará los objetos web que un usuario visualiza a los 
		pocos milisegundos de ingresar a un sitio web. Como no existía una versión del mapa 
		de objetos en la segunda versión de la aplicación, como primera instancia se agregó
		una versión preliminar del mapa de objetos tal como existía en la primera versión 
		(ver figura \ref{mapadeobjetosv1}) que descataba todos los elementos del \textit{DOM} de un documento 
		\textit{HTML}, luego se ideó un mapa de objetos que diferenciaba los elementos más 
		a menos vistos siguiendo un algoritmo de suma de matrices, donde la matriz era 
		gráficada (ver figura \ref{escaladecolores}) para generar una imagen que era fusionada a otra imagen tomanda del 
		sitio web analizado bajando la opacidad en cada una. En la figura \ref{mapadecolores} 
		es posble visualizar lo descrito previamente. \\ \\
		Para llevar a cabo el trabajo fue dividido por el practicante en tres etapas que se 
		describen brevemente a continuación:
			\begin{enumerate}
				\item \textbf{Exploración del código previo}: Dado que el trabajo consitió
				en agregar el mapa de objetos en una tecnología desconocida, fue necesario 
				estudiar el framework tanto su sintaxis como su filosofía de programación, para 
				luego comenzar a explorar el código existente dentro de la aplicación de forma de 
				identificar aquellas clases y funciones claves involucradas a la partes a extender.
				\item \textbf{Migración del código}: Como no existía un mapa de objetos en la nueva
				en la segunda versión de la aplicación, se tomó parte del algoritmo existente en la 
				versión del mapa de objetos, y se realizó una migración del código \textit{JAVA} a 
				\textit{Python} obteniendo un mapa de objetos que encerraba los objetos web
				tal como en la versión anterior.
				\item \textbf{Refactoring}: Luego de agregar el mapa de objetos en su versión 
				preliminar, se ideó un algoritmo de sumas de matrices, en donde se tomaban los datos
				de visualización (obtenidos con algoritmos de minería de datos y las otras técnicas
				mencionadas) en forma de una matriz de observación para luego fusionarla con una 
				matriz que representaba el sitio (es decir, se tomó una fotografía del sitio web
				y se hizo una conversión a su representación matricial) en una escala de opacidad
				tal como se aprecia en la figura \ref{mapadecolores}.
				\item \textbf{Etapa de FrontEnd}: Una vez listas las funciones y algoritmos de 
				las etapas anteriores, se pasó a la última etapa en la que utilizando 
				\textit{Javascript} y funciones \textit{AJAX} se implementó el mapa de objetos 
				final dentro de la aplicación web, tal como se muestra en la figura \ref{objmap} y 
				está disponible en su sitio oficial \cite{ref3}.}
			\end{enumerate}
			
\newpage
\section{Trabajo Realizado}

	\newpar{Como se ha mencionado previamente el trabajo consitió en la creación de un mapa 
	de los objetos web \cite{ref9} más relevantes que un usuario visualiza mientras navega en un sitio web.
	Los datos
	que se usaron para indicar donde se encontraban los objetos claves eran recibidos desde el 
	mapa de fijación ocular (que se explicó en las secciones pasadas) que fueron obtenidos por 
	algoritmos de minería de datos, eye tracking, y electroencefalografía. Estos datos son el 
	punto de partida del mapa de objetos implementado. Los datos eran representados en una imagen basada en un \textit{screenshot} \cite{ref11} del sitio que se estaba 
	analizando, la imagen tenía una coloración más intensa en los 
	lugares más probables (ver figura \ref{mapadefijacion}) que un usuarios fijaría su atención en los primeros milisegundos. Luego se realizaba conversión de la imagen de visualización a sus representación matricial (ver figura \ref{matricial}) con números enteros entre 0 a 255 (que es la escala de colores RGB \cite{ref12}) los lugares dentro de la matriz que tenían numeros más altos correspondían a las zonas más probables de observación. 
	Finalmente, se gráficaba dicha matriz generando una imagen como la de la figura \ref{escaladecolores}, dicha
	imagen se fusionaba con un \textit{screenshot} del sitio web produciendo la imagen 
	que se puede apreciar en la figura \ref{mapadecolores}, los colores más oscuros representaban los objetos más
	vistos, el último paso fue agregar estos cambios a la aplicación oficial. \\ \\
	A continuación se explicará en profundidad el detalle del proceso descrito y las etapas 
	mencionadas en la sección anterior.}
	
	\subsection{Etapa 0}
        
        \newpar{El primer paso realizar las modificaciones solicitadas fue identificar las clases
        involucradas en el mapa de objetos de la versión \textit{JAVA}. Esta exploración se realizó
        al mismo tiempo que el practicante aprendió sobre los elementos específicos para el desarrollo
        de aplicaciones web \textit{Django}, como lo son los modelos, vistas, templates en especial
        elementos de \textit{HTML} y \textit{CSS}.} 
        
        \subsubsection{Algoritmo Mapa de Objetos versión \textit{Java}}
        
        \newpar{A pesar de que existía un mapa de objetos en la versión 1 del proyecto, el algoritmo
        no contaba con una clase propia dentro del código de la aplicación. A continuación 	
        se realizará una explicación más detallada del código de la subsección \ref{subseccion141} 
        (ver código \ref{version-java}) siguiendo paso a paso su ejecución:}
        
        \begin{enumerate}
         \item Para obtener todos los elementos del \textit{DOM} se empleaba una consulta al 
         \textit{WebDriver Object} un objeto perteneciente a la biblioteca \textit{Selenium} 	
         para
         \textit{JAVA} encargado de ejecutar llamadas directas al navegador y conseguir información
         (\textit{Web Scrapping} \cite{ref8}) del sitio en cual se estaba navegando, luego usando el 
         método \textit{findElements} se llevaba cabo la consulta que era conseguir todos los 
         \textit{WebObject} que poseían un \textit{TagName}, cuyo nombre de etiqueta 
         (\textit{TagName}) era referido a las etiquetas de \textit{HTML}, dichos elementos
         eran guardados en una variable query que era una instancia de la clase  
         \textit{ArrayList Object}, como su nombre lo indica es el objetos que representa las en 
         \textit{JAVA}.
			\begin{lstlisting}[style=Java, caption={Obtención \textit{WebObjects}.}]
           	query = driver.findElements(By.tagName(temp.tagName()));
\end{lstlisting}
		\item Luego, para dibujar el mapa de objetos se ingresaba a un bucle manejado por un ciclo
		\textit{for} en el cual se recorría la lista de \textit{Web Objects}, y utilizando los 
		objetos \textit{Point} y \textit{Dimesion} ambos provenientes de la biblioteca de 
		\textit{Selenium}, el cual dichos objetos guardaban las posiciones de objeto web 
		en la representación matricial del \textit{screenshot} del sitio de estudio. Dichas
		posiciones servían para instanciar un objeto \textit{Rectangle} de la clase estándar
		de \textit{JAVA}, y finalmante con un objeto \textit{Draw} eran dibujados dentro del 
		\textit{screenshot} tomado. En el siguiente código puede apreciarse una versión simplificada
		de dicho algoritmo.
					\begin{lstlisting}[style=Java, caption={Algoritmo mapa de objetos simplificado.}]
for (WebElement temp1 : query) {
	Point po = temp1.getLocation();
    Dimension d = temp1.getSize();
    graph.draw(new Rectangle(po.x, po.y, d.width, d.height));
}
\end{lstlisting}
		\item Algunos puntos que fueron omitidos del algoritmo anterior es que podían existir 
		errores en su ejecución que provenían el sitio web que se estaba analizando. Dichos errores fueron 
		neutralizados con sentencias \textit{try-catch}, aislando así los errores más frecuentes.
		\item El último punto importante a mencionar existían algunos objetos web cuyo tamaño 
		escapaba las dimensiones de la pantalla donde se visualizaba el sitio web, dichos objetos
		no fueron considerados dentro del mapa de objetos debido a que no eran importantes 
		para el análisis de determinar los objetos web más visto por el usuario. Estos 
		se aislaban de acuerdo a sí las posiciones del web object escapaban a una coordenada
		negativa. Una sentencía \textit{if} se encargaba de lo indicado. 
		\begin{lstlisting}[style=Java, caption={Condición de borde.}]
if (d.width <= 0 || d.height <= 0 || po.x < 0 || po.y < 0) {
	continue;
}
\end{lstlisting}
        \end{enumerate}
        
	\subsection{Etapa 1: Migración}
	
	\newpar{Una vez encontradas las clases involucradas y aprendido el funcionamiento de 
	\textit{Django}, se procedió a migrar el algoritmo del mapa de objetos ya existente
	al lenguaje \textit{Python} testeando el resultado con \textit{PhantomJS} y la biblioteca
	de \textit{Selenium} para \textit{Python}. La depuración del algoritmo puede ser dividada
	en las siguientes fases que implementan el mapa:}
	\newpage
		\begin{enumerate}
			\item \textbf{Importación}: Para migración del código se utilizaron las siguientes
			bibliotecas de Python:
			\begin{lstlisting}[style=Python, caption={Bibliotecas utilizadas para el mapa de objetos.}]
from selenium import webdriver
from selenium.webdriver.common.by import By
from PIL import Image, ImageDraw
\end{lstlisting}
			\item \textbf{Obtención  del \textit{Screenshot} del sitio web}: Una vez elegida la
			url del sitio web a analizar, se obtenía un \textit{screenshot} del sitio web con 
			la ayuda de \textit{PhantomJS} seteando el tamaño de la ventana y la url para luego
			ser guardadas dentro del servidor. Luego utilizando la biblioteca de edición de imágenes
			se instanciaban los objetos, \textit{Imagen}, que abría que la imagen a editar y 
			\textit{ImageDraw}, que editaba la imagen abierta, en este caso el \textit{screenshot}.
			\begin{lstlisting}[style=Python, caption={Destacación de objetos web}]
driver = webdriver.PhantomJS()
driver.set_window_size(1301, 744)
driver.get("http://google.com")
driver.save_screenshot("/path/screenshot.png")
image = Image.open("/path/screenshot.png")
draw = ImageDraw.Draw(image)
\end{lstlisting}
			\item \textbf{Obtención de objetos web}: Con la biblioteca \textit{Selenim} era
			posible conseguir todos objetos que poseía el sitio, utilizando una consulta que
			obtenía todos los elementos dentro del body que manejaban un \textit{tag name},
			retornando una lista con los objetos web.
\begin{lstlisting}[style=Python, caption={Consulta al body del sitio web.}]
element = driver.find_element(By.TAG_NAME, 'body')
body = element.find_elements(By.XPATH, './/*')
\end{lstlisting}
		\item \textbf{Destacación de objetos web}: Finalmente, a través de un ciclo se recorría
		la lista de elementos dibujando un rectangulo en el \textit{screenshot} que descataba la 
		posición de dicho objetos en cada iteración. La posición exacta era determinada la librería 
		\textit{Selenium}.
\begin{lstlisting}[style=Python, caption={Algoritmo mapa de objetos de simplificado
versión \textit{Python}.}]
for b in body:
	x1 = b.location['x']
	y1 = b.location['y']
	x2 = x1 + b.size['width']
	y2 = y1 + b.size['height']
	draw.rectangle([x1, y1, x2, y2], outline = 255)
\end{lstlisting}
		\end{enumerate}				
		
	\newpar{El resultado era un mapa igual al de la figura \ref{mapadeobjetosv1}. Algunas partes del código han
	sido omitidas debido a que no formaban parte escencial de la explicación.}
\newpage
\subsection{Etapa 2: Refactoring}
	\subsubsection{Diseño}
	\newpar{Antes de detallar el funcionamiento del código realizado se explicará el patrón de 
	diseño utilizado. Como se dijo en secciones pasado el framework \textit{Django} sigue el patrón
	\textit{Modelo Vista Controlador} (MVC) \cite{ref7}. \\ \\ 
	El MVC consta de las siguientes partes: \\
	\begin{enumerate}
		\item \textbf{Modelo}: Su responsabilidad es el manejar la representación de la información 
		con la cual se está trabajando, por lo tanto le corresponde interactuar y gestionar dicha 
		información.
		\item \textbf{Controlador}: Es el intermediario entre la vista y el modelo, le corresponde 
		responder a eventos y enviar peticiones al modelo. Sin embargo, para el caso \textit{Django} 
		recibe el nombre de Vistas, \textit{Views} en inglés.
		\item \textbf{Vista}: Muestra la información de forma gráfica al usuario, en un formato 
		apropiado. La información mostrada corresponde a la información que provee el modelo. En
		el caso de \textit{Django} reciben el nombre de templates.
	\end{enumerate}
	Aplicando este modelo a las responsabilidades identificadas en la programación del mapa de 
	objetos se obtuvo lo que cada parte del MVC debe realizar.
	\begin{enumerate}[label=\alph*) ,font=\bfseries] % Fuente en negrita
				\item El \textbf{Modelo} debe encargarse de la extracción de datos, pues el modelo 
				el que debe encargarse de interactuar y gestionar la información.
				\item La \textbf{Vista}, o los \textit{templates}, deben en encargarse de desplegar
				el mapa de objetos cuando se inserta una url de un sitio web a análizar. 
				\item El \textbf{Controlador}, o las \textit{Views}, que se encargan de toda la 
				lógica de programación del mapa de objetos claves.
	\end{enumerate}
	}
	\subsubsection{Funcionamiento}
	\newpar{Con la migración del código \textit{JAVA} a \textit{Python} fue posible desarrollar
	un mapa más completo donde se diferenciarán los objetos más vistos a lo menos vistos. Como ya
	se había mencionado en secciones previas; los datos que mostraban las posiciones de los 
	objetos web más vistos dentro del sitio de estudio, provenían de la imagen (del sitio
	web) que generaba el mapa de fijación (ver figura \ref{mapadefijacion}). Para trabajar con estos datos, se 
	procedía a transformar la imagen a su representación matricial, en cual donde antes habían 
	existido colores más intensos ahora estaba la concentración de los números más grandes. Sin embargo, 
	estos valores eran entre 0 a 1, para tener un mayor acercamiento a la escala de colores RGB
	se ponderaba la matriz para obtener valores de 0 a 255, con la función definida en el siguiente
	código:}
	\begin{lstlisting}[style=Python, caption={Función que pondera la matrix a valores enteros.}]
def multiplier_matrix(matrix):
	matrix = matrix.T * (255.0 / max(matrix))
	return matrix
\end{lstlisting}
	
	\newpar{Para obtener la representación matricial del mapa de fijación ocular se empleó de la 
	biblioteca de \textit{Python}, \textit{matplotlib} \cite{ref13}, (usada para la generación de 
	gráficos) con el método \textit{imread} que retornaba la matriz de la imagen que recibe como
	entrada.}
\begin{lstlisting}[style=Python, caption={Forma matricial de una imagen.}]
matrix = matplotlib.image.imread(screen_path)
\end{lstlisting}

\newpar{Sin embargo, la concentración de valores en la matriz producida por el mapa de fijación
	no era regular, en el sentido que los objetos en el mapa de objetos claves eran representados 
	rectangulos y en dicha matriz la distribución de concentración era irregular, por lo tanto se 
	creó otra matriz, llamada matriz de opacidad, para rellenar sus valores en función
	de la concentración de la matriz generada por el mapa de fijación y con forma de rectangulo 
	para así respetar la forma de cada objeto web dentro del sitio web. Para ello se utilizó la 
	función \textit{buildMatrix} que rellenaba una matriz de ceros con cierto valor de opacidad
	en las posiciones de cada objeto web, el código de la función es el siguiente: }
\begin{lstlisting}[style=Python, caption={Función de construcción para la matriz de opacidad.}]
def buildMatrix(matrix, x1, y1, x2, y2, alpha):
	i = x1
	while (i != x2):
		j = y1
		if alpha < matrix[i, j]:
			break
		while (j != y2):
			if alpha < matrix[i, j]:
				break
			matrix[i, j] = alpha
			j += 1
		i += 1
	return matrix
\end{lstlisting}

\newpar{La matriz retornaba por la función \textit{buildMatrix} elaboraba un mapa de 
colores en función de las posiciones de los objetos web, para obtener la imagen
proyectada por dicha matriz, se graficaba la matriz gracias a la función \textit{plot} 
de la biblioteca \textit{matplotlib} \cite{ref13} y guardaba el archivo con el método
\textit{save} de la misma biblioteca. Finalmente se efectuaba una fusión del mapa de 
colores obtenido y un \textit{screenshot} del sitio web, marcando cierta opacidad 
para que el mapa de colores resaltará los objetos web previsto en el \textit{sceenshot}. El resultado de esto se encuentra en la figura \ref{mapadecolores} y es realizado por el código de la función \textit{objmapColor}, donde el método \textit{blend} se encarga de la fusión de la imágenes pasadas como argumento, su tercer argumento indica la escala de opacidad, en este caso
es 0.5.}
\begin{lstlisting}[style=Python, caption={Fusión de imágenes}]
def objmapColor(screenshot, path, matrix, color_string):
    '''Funcion que retorna la image final para el mapa de objeto realizando un blend entre el screenshot y el mapa de colores.
    parametro screenshot: imagen de screenshot tomando de la pagina.
    parametro path: path donde se almacena el screenshot tomado de la pagina web.
    parametro matrix: matriz de opacidad.
    parametro: color que se quiere para el mapa de color.
    '''
    mpimg.imsave(path, matrix, cmap = color_string)
    img = Image.open(path)
    output = Image.blend(screenshot, img, 0.5)
    return output
\end{lstlisting}
\newpar{El resto del algoritmo de construcción del mapa de objetos es análogo a los explicado en la subsección anterior por lo que la omitimos. Es importante descatar que el funcionamiento explicado corresponde a los controladores de la aplicación que luego fueron añadidos al archivo \textit{Views} del proyecto, dejando para la subsección siguiente la implementación de las Vistas, es decir el despliegue del mapa de objetos
dentro de la aplicación web.}

\subsection{Etapa 3: FrontEnd}
\newpar{Una vez implementada la lógica del algoritmo, la etapa final fue 
trasladar el algoritmo a la aplicación y visualizar el mapa de objetos dentro del servidor. Como
bien se ha dicho el framework \textit{Django} separa las responsabilidades siguiendo el patrón de
diseño MVC, en la subsección anterior se explicó la lógica detrás del mapa de objetos que dentro 
de la aplicación corresponde al \textit{Controlador} (las \textit{Views} en \textit{Django}), la 
parte del \textit{Modelo} era proporcionada por los datos del mapa de fijación, por ende, esta etapa 
se centra en el desarrollo de las \textit{Vistas}, que en \textit{Django} reciben el nombres de 
\textit{Templates}. \\ Como el practicante debió agregar nueva funcionalidad a una aplicación 
existente mucha parte del código que producía la inferfaz de usuario ya estaba hecho, por lo que 
esta parte del trabajo se restringió en añadir la interfaz de usuario del mapa de objetos. }

\newpar{El desarrollo del despliegue del mapa de objetos se divide en dos paso, el primero
son las llamadas \textit{AJAX} que se encargan de procesar la información obtenida para generar
el mapa de objetos sin recargar la página por completo y el segundo, la creación del contenedor
que recibirá el mapa de objetos que es mostrado al usuario. Para simplificar el manejo del código a las llamadas \textit{AJAX} se utilizó la biblioteca \textit{JQuery} perteneciente a 
\textit{JavaScript}. A continuación se detallan los pasos mencionados dentro de la ejecución del
código:}
\begin{enumerate}[label=\alph*) ,font=\bfseries] 
\item \textbf{Llamadas \textit{AJAX}}: Se creó una función \textit{JavaScript} nombrada 
\textit{objmap} encargada de ejecutar la llamadas \textit{AJAX} siguiendo la sintaxis de 
\textit{JQuery}, dicha función realizaba una solicitud GET del protocolo HTTP para conseguir
la información del mapa de fijación, con un \textit{timeout} 120000 milisegundos antes de efectuar
la petición, una vez obtenidos los datos se ejecutaba la función de la variable \textit{success} 
propia de \textit{JQuery}. La sintaxis \textit{\$.ajax\{...\}} se utiliza para ejecutar llamadas
\textit{AJAX}, por lo tanto la funcionalidad del objeto \textit{XMLHttpRequest} (objeto usado para 
interacción entre servidor y cliente mediante las solicitudes y respuestas genereadas entre ellos) \cite{ref14}
quedaba encapsulada por la biblioteca \textit{JQuery} \cite{ref15}. En el siguiente código se muestra lo descrito.
\newpage
\begin{lstlisting}[style=Java, caption={Llamada \textit{AJAX} para despliegue del Mapa de Objetos.}]
function objmap(sitio){
$.ajax(
{
type: 'GET',
timeout:120000,
url:'https://{{ request.META.HTTP_HOST }}/objmap/',
data:{url: sitio},
success: function(data){...}
}
\end{lstlisting}
\item \textbf{Visualización}: Una vez obtenidos los datos, se ejecutaba la función dentro de la variable \textit{success}, donde la variable \textit{urlobj} guardaba los datos y mientras se 
procesaba la información se oculta el \textit{div} contenedor del mapa de objetos (cuyo nombre
dentro \textit{DOM} es \textit{objemapdiv}). Luego el elemento \textit{HTML} para carga la imagen
(cuya etiqueta es \textit{img} y se añade al \textit{div} contenedor) para a ser visualizado por un 
botón cuando el mapa ya es operativo.
\begin{lstlisting}[style=Java, caption={Función de despligue del Mapa de Objetos.}]

success: function(data){
urlobj = data;
$("#objmapdiv").hide();
  
 var imgdata = '<a id="objmaplink" href="'+urlobj+'_r.png" rel="prettyPhoto"><img src="'+urlobj+'_r.png" alt="objmap"></a>';
$("#objmapdiv").html(imgdata);
$("#objmaplink").prettyPhoto();
$("#objmapdiv").slideDown(800);
totalTime = (new Date().getTime()-ajaxTime)/1000;
 totalTime = totalTime.toFixed(2);
 $("#objmaptime").html('¡Se demoró '+totalTime+' segundos!' );
 $(".clickMe").show()
},
error: function(x, t, m) {
}
})
\end{lstlisting}
\item \textbf{Funcionalidad Cambio de Colores}: En secciones previas se dijo que para la versión 
final de mapa colores existen cuatro tonalidades de colores rojo, azul naranjo y verde. Para lograr
cambiar el tipo de mapa dinámicamente se programó una función \textit{JavaScript} que se llamaba al presionar botón del color correspodiente, dicha función se ejecuta desde el lado del cliente. Esta función recibía como argumento la ruta de la imagen
a modificar, y creaba un etiqueta \textit{HTML} de inserción de imagen, que luego era redireccionada
al \textit{div} contenedor del mapa de objetos con al ayuda del método \textit{.sliveDown\(\)} de la
libería \textit{JQuery}. Dicha función recibía la firma \textit{objmapColor\(color\)}, donde su 
argumento correspondía a la ruta del archivo con el mapa de objeto ya creado en el color 
correspondiente. El siguiente código muestra la funcionalidad descrita.
\newpage
\begin{lstlisting}[style=Java, caption={Función que genera el cambio de colores en el Mapa de Objetos.}]
function objmap_color(color) {
var aux = color;      
var imgdata = '<a id="objmaplink" href="'+urlobj.concat(aux)+'" rel="prettyPhoto"><img src="'+urlobj.concat(aux)+'" alt="objmap"></a>';
$("#objmapdiv").html(imgdata);
$("#objmaplink").prettyPhoto();
$("#objmapdiv").slideDown(800);
}
\end{lstlisting}
\item \textbf{Código HTML}: El último paso consitió en agregar al templates las etiquetas 
\textit{HTML} necesarias para desplegar el mapa de objetos, las cuales fueron el \textit{div}
contenedor, los 4 botones que modificaban la versión de color del mapa de objetos y una 
etiqueta que agregaba un pequeño párrafo donde se mostraba el tiempo tardaba en cargar el mapa.
Esto se aprecia en el siguiente código \textit{HTML} y se visualiza en la figura \ref{mapas}.
\begin{lstlisting}[style=Java, caption={Contenido \textit{HTML} donde se aloja el Mapa de Objetos.}]
<div class="span4">
  <div id="objmapdiv" class="mask2">
  <div class="loadercontainer"><div class="loader"></div></div>
</div>
<div id="objdiv" class="inside">
  <hgroup id="group" style="text-align:center;">
    <h2 class="titleservice">Mapa de Objetos Claves</h2>
     <p id="objmaptime" class="subtitle"></p>
     <input class="clickMe" type="button" value="Rojo" onclick="objmap_color('_r.png');"/>
     <input class="clickMe" type="button" value="Azul" onclick="objmap_color('_b.png');" />
     <input class="clickMe" type="button" value="Verde" onclick="objmap_color('_g.png');"/>
     <input class="clickMe" type="button" value="Naranjo" onclick="objmap_color('_o.png');"/> 
  </hgroup>
</div>                        
</div>
\end{lstlisting}
\end{enumerate}

\newpar{En las figuras \ref{rojo}, \ref{azul}, \ref{verde} y \ref{naranjo} pueden 
observarse las distinas tonalidades del mapa de objetos cambiados por su respectivo botón.}
\newpar{Sí bien la última parte es bastante simple está fue la forma indicada por el tutor de práctica,
ya que se estaba trabajando en una nueva interfaz a toda a la aplicación que no formaba parte del
trabajo pedido al prácticante.}


\newpage
\section{Conclusiones}
 	\newpar{Los resultados del trabajo presentado en este informe fueron considerados por el tutor
 	de práctica como satifactorios, siendo estos puestos en producción al poco tiempo de finalizada la 			práctica, los cuales pueden ser apreciados en la página oficial del \textit{Proyecto AKORI} 			\cite{ref3}. Además gracias a la programación hecha por el prácticante cuando se ingresa la url del sitio web a analizar no solo es posible generar un mapa de los objetos más relevantes encerrados por rectángulos, sino que existe un mapa en escala de intensidad de colores de los objetos web más a los menos vistos por un usuario (en el sitio web que se está analizando), cambiando la escala en cuatro colores rojo, naranjo, azul y verde. \\ \\ Respecto al futuro de la aplicación
 	hay que destacar que aún se encuentra trabajando en ella realizando actulizaciones para mejorar su llegada al público o a los posible clientes (si llega a comercializarse) en términos de 
 	visualizaciones que le provean más y mejor información al usuario sobre el sitio web a analizar, 
 	en particular se seguirá trabajando en las secciones modificadas y agregadas por el practicante,
 	en miras de mejorar la performance de las visualizaciones de los elementos más vistos dentro 
 	del DOM en el mapa de objetos mediante optimizaciones en la extracción de datos y algoritmos
 	de búsqueda de objetos web más eficientes. \\ \\ Dentro del aprendizaje obtenido en el proceso
 	de práctica se destacan a nivel técnico el aprendizaje del framework \textit{Django} para el desarrollo web y sus elementos específicos como vistas, modelos, templates. También el aprendizaje 
 	de \textit{Javascritp} es especialmente el uso de \textit{AJAX} para el despligue del mapa de
 	objetos sin actualizar la página completa y \textit{Git} para el manejo de control de versiones.
 	Otro punto no menos importante dentro del aprendizajes de todas las tecnologías fue lo 
 	primordial que es leer la documentación antes de utilizar cualquier tecnología ya que 
 	simplifica mucho el tiempo de aprendizaje. Dentro de otros aspectos se aprendió sobre el
 	trabajo en equipo, la importancia de mantener constantemente comunicación para realizar un 
 	buen trabajo en particular cuando se trabaja en un equipo multidisciplinario. El practicante
 	estuvo en constante contacto con algunos investigadores y el con encargado para obtener un 
 	mapa de objeto acorde a los requerimientos y entendible para cualquier usuario use la 
 	plataforma del \textit{Proyecto AKORI}. Finalmente queda destacar el aprendizaje de documentar
 	bien el código hecho para que sea fácil de entender y extender a medida que el proyecto crece, 
 	y además de contar con buen diseño en el código muchas veces esto puede resultar fácil, pero
 	en la práctica puede ser determinante la contuinidad de una aplicación robusta que pueda seguir
 	creciendo y no empezar un sistema que prácticamente hará lo mismo desde 0.}



% ANEXO
\newpage
\begin{anexo}
	\section{Figuras Importantes}
		\insertimageboxed{practica/organigrama}{scale=0.6}{Organigrama Web Intelligence Centre. \label{organigrama}}
		\insertimageboxed{practica/mapadeobjetos}{scale=0.4}{Mapa de Objetos Claves versión 1.\label{mapadeobjetosv1}}
		\insertimageboxed{practica/mapadefijacion}{scale=0.35}{Mapa de Fijación.\label{mapadefijacion}}
		\insertimageboxed{practica/matricial}{scale=0.35}{Representación matricial del Mapa de Fijación.\label{matricial}}
		\insertimageboxed{practica/escaladecolores}{scale=0.48}{Escala de colores del Mapa de Objetos Claves.\label{escaladecolores}}
		\insertimageboxed{practica/mapadecolores}{scale=0.35}{Mapa de Objetos Claves versión 2.\label{mapadecolores}}
		\insertimageboxed{practica/akori}{scale=0.48}{Interfaz de la Plataforma del \textit{Proyecto AKORI}\label{akori}.}
		\insertimageboxed{practica/reporte}{scale=0.48}{Análisis del sitio web de \textit{GOOGLE}.\label{reporte}}
		\insertimageboxed{practica/cargando}{scale=0.48}{Procesamiento de información.\label{cargando}}
		\insertimageboxed{practica/mapas}{scale=0.48}{Mapas desplegados.\label{mapas}}
		\insertimageboxed{practica/objmap}{scale=0.48}{Acercamiento del Mapa de Objetos Claves.\label{objmap}}
		\insertimageboxed{practica/rojo}{scale=0.48}{Mapa de Objetos Claves en escala de rojo.\label{rojo}}
		\insertimageboxed{practica/azul}{scale=0.48}{Mapa de Objetos Claves en escala de azul. \label{azul}}
		\insertimageboxed{practica/verde}{scale=0.48}{Mapa de Objetos Claves en escala de verde.\label{verde}}
		\insertimageboxed{practica/naranjo}{scale=0.48}{Mapa de Objetos Claves en escala de naranjo.\label{naranjo}}
	
\end{anexo}

% REFERENCIAS (ESTILO BIBTEX)
\newpage % Salto de página
\begin{references}
	\bibitem{ref1}
	\textit{Sitio Web del WIC}
	\url{http://www.wic.uchile.cl}
	
	\bibitem{ref2}
	\textit{Página Oficial del Proyecto AKORI} 
	\url{https://www.akoriproject.cl}
	
	\bibitem{ref3}
	\textit{Sitio oficial de lenguaje de programación \textit{Python}}
	\url{https://www.python.org/}
	
	\bibitem{ref4}
	\textit{PyCharm IDLE}
	\url{https://www.jetbrains.com/pycharm/}
	
	\bibitem{ref5}
	\textit{El framework \textit{Django}}
	\url{https://www.djangoproject.com/}
	
	\bibitem{ref6}
	\textit{Biblioteca SELENIUM}
	\url{http://www.seleniumhq.org/}
	
	\bibitem{ref7}
	\textit{Patrón Modelo Vista Controlador}
	\url{https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller}
	
	\bibitem{ref8}
	\textit{Definición del término Web scraping}
	\url{https://es.wikipedia.org/wiki/Web_scraping}
	
	\bibitem{ref9}
	\textit{Publicación del WIC donde son definidos los objetos web}
	\url{http://wic.uchile.cl/wp-content/uploads/2015/08/Eye-tracking-and-EEG-features-for-salient-Web-object-identification.pdf}
	
	\bibitem{ref10}
	\textit{Definición elementos del DOM}
	\url{https://es.wikipedia.org/wiki/Document_Object_Model}
	
	\bibitem{ref11}
	\textit{Definición de un Screenshot}
	\url{https://en.wikipedia.org/wiki/Screenshot}
	
	\bibitem{ref12}
	\textit{Escala RGB}
	\url{https://es.wikipedia.org/wiki/RGB}
	
	\bibitem{ref13}
	\textit{Biblioteca de generación de gráficos}
	\url{https://matplotlib.org/}
	
	\bibitem{ref14}
	\textit{Objeto XMLHttpRequest}
	\url{https://es.wikipedia.org/wiki/XMLHttpRequest}
	
	\bibitem{ref15}
	\textit{Biblioteca JQuery}
	\url{https://jquery.com/}
	
	
	

\end{references}
